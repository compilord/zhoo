use crate::util::color::Color;
use crate::util::error::ReportMessage;
use crate::util::span::Span;

pub enum SyntaxKind {
  /// generated by the parser when it encounters a token (or EOF) it did not
  InvalidToken(Span),

  /// generated by the parser when it encounters an EOF it did not expect.
  UnrecognizedEOF(Span, String),

  /// the unexpected token: generated by the parser when
  /// it encounters a token it did not expect.
  UnrecognizedToken(Span, String),

  /// generated by the parser when it encounters additional, unexpected tokens.
  ExtraToken(Span, String),

  /// Custom error type.
  User(String),
}

pub fn write_syntax_report(kind: &SyntaxKind) -> ReportMessage {
  use ariadne::Fmt;

  match kind {
    SyntaxKind::InvalidToken(_span) => (format!("{}", "invalid token".fg(Color::title())), vec![], vec![]),
    SyntaxKind::UnrecognizedEOF(_span, _eof) => (format!("{}", "unrecognized eof".fg(Color::title())), vec![], vec![]),
    SyntaxKind::UnrecognizedToken(_span, _expected) => (
      format!("{}", "unrecognized character".fg(Color::title())),
      vec![],
      vec![format!(
        "{}",
        "in other languages this character is valid but the qhantoom syntax does not recognize it.".fg(Color::hint())
      )],
    ),
    SyntaxKind::ExtraToken(_span, _unexpected) => (format!("{}", "extra token".fg(Color::title())), vec![], vec![]),
    SyntaxKind::User(error) => (format!("{}", error.fg(Color::title())), vec![], vec![]),
  }
}
